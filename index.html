<!DOCTYPE html>
<html>
<head>
    <title>3D Whack-a-Mole</title>
    <style>
        /* Hide UI elements as you already have */
        [data-version-indicator],
        [data-progress-bar],
        [data-instructions],
        .scoreElement,
        .timerElement,
        .instructionsElement,
        #scoreElement,
        #timerElement,
        #instructionsElement {
            display: none !important;
        }
        
        /* Grass overlay styles */
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            position: relative;
        }
        
        #grassOverlay {
            position: absolute;
            bottom: 0; /* Align to bottom edge */
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to the game */
            z-index: 10; /* Above the canvas but below UI elements */
            transform-origin: bottom center; /* Set transform origin to bottom center */
            /* The transform scale can be adjusted to match hole positions */
            transform: scale(1.05); /* Slight scale adjustment to match hole positions */
            background-color: rgba(76, 175, 80, 0.4); /* Fallback green background if image fails to load */
        }
        
        #grassImage {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            pointer-events: none;
            opacity: 0.9;
            display: block; /* Ensure image is displayed as block element */
        }
        
        /* Add CSS for canvas positioning to ensure alignment */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* For adjustment UI - hidden by default */
        #adjustmentControls {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
            display: none;
            font-family: Arial, sans-serif;
        }
        
        #adjustmentControls button {
            margin: 5px;
            padding: 5px 10px;
            cursor: pointer;
        }
        
        .controlRow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
        }
        
        .label {
            width: 100px;
            text-align: right;
            padding-right: 10px;
        }
        
        .value {
            width: 50px;
            text-align: center;
        }
        
        .buttons {
            display: flex;
        }
        
        .buttons button.small {
            padding: 2px 5px;
            margin: 0 2px;
            font-size: 10px;
        }
        
        .toggle {
            padding: 8px 12px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            width: 100%;
            margin-top: 10px;
        }
        
        /* Add red marker for debugging */
        .debug-box {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 20px;
            height: 20px;
            background-color: red;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Add canvas container -->
    <div id="canvasContainer"></div>
    
    <!-- Add this div for the grass overlay -->
    <div id="grassOverlay">
        <img id="grassImage" src="grass-texture.jpg" alt="Grass Texture" />
        <!-- Add debug marker at bottom center -->
        <div class="debug-box"></div>
        <!-- Fallback grass overlay using CSS only -->
        <div id="fallbackGrass" style="
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 65%;
            background: linear-gradient(to bottom, #4CAF50, #8BC34A);
            opacity: 0.7;
            display: none;
        "></div>
    </div>
    
    <!-- Adjustment controls - press 'A' key to show/hide -->
    <div id="adjustmentControls">
        <h3 style="text-align: center; margin: 0 0 10px 0;">Overlay Adjustment</h3>
        
        <div class="controlRow">
            <span class="label">Scale:</span>
            <span class="value" id="scaleValue">1.05</span>
            <div class="buttons">
                <button class="small" onclick="adjustScale(-0.01)">-</button>
                <button onclick="adjustScale(-0.05)">--</button>
                <button onclick="adjustScale(0.05)">++</button>
                <button class="small" onclick="adjustScale(0.01)">+</button>
            </div>
        </div>
        
        <div class="controlRow">
            <span class="label">X Position:</span>
            <span class="value" id="xValue">0</span>
            <div class="buttons">
                <button class="small" onclick="adjustPosition('x', -1)">-</button>
                <button onclick="adjustPosition('x', -5)">--</button>
                <button onclick="adjustPosition('x', 5)">++</button>
                <button class="small" onclick="adjustPosition('x', 1)">+</button>
            </div>
        </div>
        
        <div class="controlRow">
            <span class="label">Y Position:</span>
            <span class="value" id="yValue">0</span>
            <div class="buttons">
                <button class="small" onclick="adjustPosition('y', -1)">-</button>
                <button onclick="adjustPosition('y', -5)">--</button>
                <button onclick="adjustPosition('y', 5)">++</button>
                <button class="small" onclick="adjustPosition('y', 1)">+</button>
            </div>
        </div>
        
        <div class="controlRow">
            <span class="label">Opacity:</span>
            <span class="value" id="opacityValue">0.9</span>
            <div class="buttons">
                <button class="small" onclick="adjustOpacity(-0.05)">-</button>
                <button onclick="adjustOpacity(-0.1)">--</button>
                <button onclick="adjustOpacity(0.1)">++</button>
                <button class="small" onclick="adjustOpacity(0.05)">+</button>
            </div>
        </div>
        
        <button class="toggle" onclick="tryAlternativeImage()">Try Alternative Image</button>
        <button class="toggle" onclick="generateGrassPattern()">Generate Grass Pattern</button>
        <button class="toggle" onclick="toggleOverlay()">Toggle Overlay (T)</button>
        <button class="toggle" onclick="toggleMarkers()">Toggle Markers (D)</button>
        <button class="toggle" onclick="saveAdjustments()">Save Settings</button>
        <p style="text-align: center; margin: 5px 0; font-size: 12px;">Press A to hide controls</p>
    </div>
    
    <script>
        // Adjustment controls - only used during development
        let scale = 1.05; // Starting scale
        let offsetX = 0;
        let offsetY = 0;
        let opacity = 0.9;
        let overlayVisible = true;
        
        // Debug the grass overlay after page load
        window.addEventListener('load', function() {
            console.log("Page loaded, checking overlay...");
            const overlay = document.getElementById('grassOverlay');
            const image = document.getElementById('grassImage');
            
            if (overlay && image) {
                console.log("Overlay element exists:", overlay);
                console.log("Image element exists:", image);
                
                // Check image loading
                image.onload = function() {
                    console.log("Image loaded successfully!", image.width, "x", image.height);
                };
                
                image.onerror = function(e) {
                    console.error("Error loading image!", e);
                    tryAlternativeImage();
                };
                
                // Make sure the renderer is added to the DOM
                const renderer = document.querySelector("canvas");
                if (renderer) {
                    const canvasContainer = document.getElementById("canvasContainer");
                    if (canvasContainer && renderer.parentNode !== canvasContainer) {
                        if (renderer.parentNode) {
                            renderer.parentNode.removeChild(renderer);
                        }
                        canvasContainer.appendChild(renderer);
                    }
                }
            } else {
                console.error("Overlay or image element not found!");
            }
        });
        
        // Function to generate grass pattern if all image sources fail
        function generateGrassPattern() {
            console.log("Generating fallback grass pattern using canvas...");
            
            const canvas = document.createElement('canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight * 0.65; // Cover bottom 65%
            
            const ctx = canvas.getContext('2d');
            
            // Create gradient background
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#4CAF50'); // Top color
            gradient.addColorStop(1, '#8BC34A'); // Bottom color
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add some texture/noise
            const drawNoise = () => {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Random noise value
                    const noise = Math.random() * 20 - 10;
                    
                    // Add noise to RGB channels
                    data[i] = Math.max(0, Math.min(255, data[i] + noise)); // R
                    data[i + 1] = Math.max(0, Math.min(255, data[i + 1] + noise)); // G
                    data[i + 2] = Math.max(0, Math.min(255, data[i + 2] + noise)); // B
                }
                
                ctx.putImageData(imageData, 0, 0);
            };
            
            drawNoise();
            
            // Draw some simple grass blades
            ctx.strokeStyle = '#2E7D32'; // Darker green
            ctx.lineWidth = 1;
            
            for (let i = 0; i < 500; i++) {
                const x = Math.random() * canvas.width;
                const height = 10 + Math.random() * 30;
                const y = canvas.height - height - Math.random() * 50;
                
                ctx.beginPath();
                ctx.moveTo(x, canvas.height - Math.random() * 20);
                ctx.quadraticCurveTo(
                    x + (Math.random() * 10 - 5), 
                    y + height / 2, 
                    x + (Math.random() * 16 - 8), 
                    y
                );
                ctx.stroke();
            }
            
            // Apply the canvas as background
            const grassOverlay = document.getElementById('grassOverlay');
            if (grassOverlay) {
                grassOverlay.style.backgroundImage = `url(${canvas.toDataURL()})`;
                grassOverlay.style.backgroundSize = '100% auto';
                grassOverlay.style.backgroundPosition = 'center bottom';
                grassOverlay.style.backgroundRepeat = 'no-repeat';
                
                // Hide the image and fallback div
                const image = document.getElementById('grassImage');
                const fallback = document.getElementById('fallbackGrass');
                
                if (image) image.style.display = 'none';
                if (fallback) fallback.style.display = 'none';
                
                console.log("Generated grass pattern applied as background image");
            }
        }
        
        // Update tryAlternativeImage function to use the generated pattern as a last resort
        function tryAlternativeImage() {
            const image = document.getElementById('grassImage');
            const fallbackGrass = document.getElementById('fallbackGrass');
            
            if (image) {
                // Try a different image source
                const sources = [
                    'grass-texture.jpg', // Local file (first priority)
                    'https://i.imgur.com/wJ9yFLC.jpeg', // Direct link to Imgur
                    'https://jjazut1.github.io/image-hosting/grassTexture2d.jpg',
                    '/grassTexture2d.jpg',
                    'grassTexture2d.jpg'
                ];
                
                // Get the current source index
                let currentIndex = sources.indexOf(image.src.split('/').pop());
                if (currentIndex === -1) currentIndex = 0;
                
                // Move to the next source
                let nextIndex = (currentIndex + 1) % sources.length;
                let nextSource = sources[nextIndex];
                
                console.log(`Trying alternative image source (${nextIndex + 1}/${sources.length}): ${nextSource}`);
                
                // If we've tried all sources and are back to the first one, use the fallback
                if (nextIndex === 0 && currentIndex === sources.length - 1) {
                    console.log("All image sources failed. Using CSS fallback.");
                    image.style.display = 'none';
                    
                    // Try the CSS fallback first
                    if (fallbackGrass) {
                        fallbackGrass.style.display = 'block';
                        
                        // If we're desperate, generate a pattern after a short delay
                        setTimeout(() => {
                            // Ask user if they want to try the generated pattern
                            if (confirm("Having trouble loading the grass image. Would you like to generate a grass pattern instead?")) {
                                generateGrassPattern();
                            }
                        }, 2000);
                    } else {
                        // Go straight to generated pattern
                        generateGrassPattern();
                    }
                } else {
                    image.src = nextSource;
                }
            }
        }
        
        // Check if we have saved adjustments
        if (localStorage.getItem('grassOverlaySettings')) {
            const settings = JSON.parse(localStorage.getItem('grassOverlaySettings'));
            scale = settings.scale || scale;
            offsetX = settings.offsetX || offsetX;
            offsetY = settings.offsetY || offsetY;
            opacity = settings.opacity || opacity;
            
            // Update display values
            updateDisplayValues();
            
            // Apply saved settings
            applyAdjustments();
        }
        
        function updateDisplayValues() {
            document.getElementById('scaleValue').textContent = scale.toFixed(2);
            document.getElementById('xValue').textContent = offsetX;
            document.getElementById('yValue').textContent = offsetY;
            document.getElementById('opacityValue').textContent = opacity.toFixed(2);
        }
        
        function adjustScale(amount) {
            scale += amount;
            // Prevent negative or too small scale
            if (scale < 0.1) scale = 0.1;
            updateDisplayValues();
            applyAdjustments();
        }
        
        function adjustPosition(axis, amount) {
            if (axis === 'x') {
                offsetX += amount;
            } else {
                offsetY += amount;
            }
            updateDisplayValues();
            applyAdjustments();
        }
        
        function adjustOpacity(amount) {
            opacity += amount;
            // Clamp opacity between 0 and 1
            opacity = Math.max(0, Math.min(1, opacity));
            updateDisplayValues();
            applyAdjustments();
        }
        
        function toggleOverlay() {
            overlayVisible = !overlayVisible;
            const overlay = document.getElementById('grassOverlay');
            overlay.style.display = overlayVisible ? 'block' : 'none';
            console.log("Overlay toggled:", overlayVisible);
        }
        
        function applyAdjustments() {
            const overlay = document.getElementById('grassOverlay');
            const image = document.getElementById('grassImage');
            
            overlay.style.transform = `scale(${scale}) translate(${offsetX}px, ${offsetY}px)`;
            image.style.opacity = opacity;
            
            console.log(`Applied: scale=${scale}, offsetX=${offsetX}, offsetY=${offsetY}, opacity=${opacity}`);
        }
        
        function saveAdjustments() {
            localStorage.setItem('grassOverlaySettings', JSON.stringify({
                scale: scale,
                offsetX: offsetX,
                offsetY: offsetY,
                opacity: opacity
            }));
            alert('Settings saved!');
        }
        
        function toggleMarkers() {
            toggleHoleMarkers();
        }
        
        // Key press handler to show/hide adjustment controls
        document.addEventListener('keydown', function(event) {
            if (event.key.toLowerCase() === 'a') {
                const controls = document.getElementById('adjustmentControls');
                controls.style.display = controls.style.display === 'none' ? 'block' : 'none';
            }
            
            // Press D to toggle debug markers for hole positions
            if (event.key.toLowerCase() === 'd') {
                toggleHoleMarkers();
            }
            
            // Press T to toggle grass overlay
            if (event.key.toLowerCase() === 't') {
                toggleOverlay();
            }
        });
        
        // Function to create visual markers for hole positions
        function toggleHoleMarkers() {
            const existingMarkers = document.querySelectorAll('.hole-marker');
            
            // If markers exist, remove them
            if (existingMarkers.length > 0) {
                existingMarkers.forEach(marker => marker.remove());
                return;
            }
            
            // Wait for Three.js to be fully initialized
            setTimeout(() => {
                // This assumes your setupHolesAndMoles function has already run
                // and the holes array is available from your game
                const holePositions = [
                    { x: -1.5 * 1.5, z: -1.5 * 1.5 },
                    { x: 2 * 1.5, z: -1.5 * 1.5 },
                    { x: -2 * 1.5, z: 1.5 * 1.5 },
                    { x: 2 * 1.5, z: 2 * 1.5 }
                ];
                
                // Function to convert 3D coordinates to screen coordinates
                function toScreenPosition(x, y, z) {
                    // Access Three.js objects from window scope
                    if (!window.THREE || !window.gameCamera) {
                        console.error('THREE.js or camera not accessible');
                        return { x: 0, y: 0 };
                    }
                    
                    const vector = new window.THREE.Vector3(x, y, z);
                    const widthHalf = window.innerWidth / 2;
                    const heightHalf = window.innerHeight / 2;
                    
                    // Project the 3D point to 2D screen space
                    vector.project(window.gameCamera);
                    
                    return {
                        x: (vector.x * widthHalf) + widthHalf,
                        y: -(vector.y * heightHalf) + heightHalf
                    };
                }
                
                // Create markers for each hole
                holePositions.forEach((pos, index) => {
                    const screenPos = toScreenPosition(pos.x, 0.01, pos.z);
                    
                    const marker = document.createElement('div');
                    marker.className = 'hole-marker';
                    marker.style.position = 'absolute';
                    marker.style.left = `${screenPos.x}px`;
                    marker.style.top = `${screenPos.y}px`;
                    marker.style.width = '20px';
                    marker.style.height = '20px';
                    marker.style.borderRadius = '50%';
                    marker.style.backgroundColor = 'rgba(255, 0, 0, 0.5)';
                    marker.style.border = '2px solid red';
                    marker.style.zIndex = '1000';
                    marker.style.pointerEvents = 'none';
                    marker.textContent = index + 1;
                    marker.style.display = 'flex';
                    marker.style.alignItems = 'center';
                    marker.style.justifyContent = 'center';
                    marker.style.color = 'white';
                    marker.style.fontWeight = 'bold';
                    
                    document.body.appendChild(marker);
                    
                    // Log position for debugging
                    console.log(`Hole ${index + 1} - 3D: (${pos.x}, ${pos.z}), Screen: (${screenPos.x}, ${screenPos.y})`);
                });
                
                console.log('Hole markers added - press D again to remove');
            }, 1000); // Wait for scene to be fully loaded
        }
    </script>
    
    <script type="module">
        // This script will make Three.js objects available globally for debug purposes
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.module.js';
        
        // Expose THREE to window for debugging
        window.THREE = THREE;
        
        // Import the main game script
        import './script.js';
        
        // Make sure the canvas is in the right container
        setTimeout(() => {
            const canvas = document.querySelector("canvas");
            const canvasContainer = document.getElementById("canvasContainer");
            
            if (canvas && canvasContainer && canvas.parentNode !== canvasContainer) {
                if (canvas.parentNode) {
                    canvas.parentNode.removeChild(canvas);
                }
                canvasContainer.appendChild(canvas);
                console.log("Moved canvas to proper container");
            }
            
            // Check the grass image
            const image = document.getElementById('grassImage');
            console.log("Image status:", {
                src: image.src,
                complete: image.complete,
                naturalWidth: image.naturalWidth,
                naturalHeight: image.naturalHeight,
                isVisible: window.getComputedStyle(image).display !== 'none'
            });
            
            // If the image has failed to load or has zero width/height, try alternatives
            if (!image.complete || image.naturalWidth === 0 || image.naturalHeight === 0) {
                console.log("Image failed to load correctly. Trying alternatives...");
                tryAlternativeImage();
            }
            
            // Force the image to be visible
            image.style.display = 'block';
        }, 1000);
    </script>
</body>
</html>
